---
title: "EHMC Visualization"
author: "Samuel Thomas"
date: "December 7, 2017"
output:
  pdf_document: default
  html_document: default
header-includes:
- \usepackage{amsmath}
- \usepackage{algorithm}
- \usepackage{algpseudocode}
- \usepackage{float}
- \usepackage{animate}
- \usepackage{lipsum}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Visual Comparison:  EHMC vs. Metropolis-Hastings

Gamma distribution

$$
f(x) = \frac{1}{\beta^\alpha \Gamma(\alpha)} x^{\alpha-1}e^{-x/\beta}I_x(0, \infty)
$$
With likelihood and log-likelihood

$$
\begin{aligned}
L(\alpha, \beta; x) &= \prod_{i=1}^n \frac{1}{\beta^\alpha \Gamma(\alpha)} x_i^{\alpha-1}e^{-x_i/\beta} \\
l(\alpha, \beta;x) &= \sum_{i=1}^n -\alpha\log\beta -\log\Gamma(\alpha) + (\alpha-1)\log x_i - x_i/\beta \\
&= -n\alpha\log\beta -n\log\Gamma(\alpha) + (\alpha-1)\sum_{i=1}^n\log x_i - \frac{1}{\beta}\sum_{i=1}^n x_i
\end{aligned}
$$

Use a Half-Normal prior for $\theta = (\alpha, \beta)$ with hyperpriors $\gamma_1$ and $\gamma_2$.  Strictly positive $\alpha \in (0, \infty)$, and $\beta \in (0, \infty)$

$$
\begin{aligned}
p(\alpha|\gamma_1) &= \frac{2\gamma_1}{\pi}\exp\left(-\frac{\alpha^2\gamma_1^2}{\pi} \right) \\
p(\beta|\gamma_2) &= \frac{2\gamma_2}{\pi}\exp\left(-\frac{\beta^2\gamma_2^2}{\pi} \right)
\end{aligned}
$$

Posterior and log-posterior

$$
\begin{aligned}
p(\alpha, \beta | x) &\propto L(\alpha, \beta; x)p(\alpha, \beta) \\
\log p(\alpha, \beta|x) &\propto l(\alpha, \beta; x) + \log p(\alpha,\beta) \\
&\propto l(\alpha, \beta; x) + \log(2\gamma_1/\pi) - \frac{\alpha^2\gamma_1^2}{\pi} + \log(2\gamma_2/\pi) - \frac{\beta^2\gamma_2^2}{\pi}
\end{aligned}
$$
$$
-n\alpha\log\beta -n\log\Gamma(\alpha) + (\alpha-1)\sum_{i=1}^n\log x_i - \frac{1}{\beta}\sum_{i=1}^n x_i
$$


In EHMC, we require the gradient of the log posterior ($\psi(\alpha)$ is the digamma function)

$$
\begin{aligned}
\nabla_\alpha \log p(\alpha, \beta|x) &= -n\log\beta -n\psi(\alpha) + \sum_{i=1}^n\log x_i -2\alpha\gamma_1^2/\pi \\
\nabla_\beta \log p(\alpha, \beta|x) &= -\frac{n\alpha}{\beta} + \frac{1}{\beta^2}\sum_{i=1}^n x_i - 2\beta\gamma_2^2/\pi
\end{aligned}
$$
Simulation: $\theta = (\alpha, \beta) = (2, 3)$ with hyperparameters set at $(\gamma_1, \gamma_2) = (1e-4, 1e-4)$

MH uses a multivariate Normal proposal $N_2(0, \text{diag}(1e-2))$

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(mvtnorm)

diagplots.mcmc <- function(result, actual.mu, burnin=100) {
  require(ggplot2)
  result.subs <- result[-c(1:burnin), ]
  pdata <- result.subs
  pdata$t <- 1:nrow(pdata)
  pdata <- reshape(pdata, 
                   varying = list(1:(ncol(pdata)-1)),
                   v.names = "value",
                   idvar = "t", 
                   timevar = "coefficient", 
                   times = colnames(pdata)[-ncol(pdata)],
                   direction = "long")
  pdata$true.mu <- rep(actual.mu, each=nrow(result.subs))
  
  k <- ncol(result)
  
  # return list
  
  # line plots of simulation
  p1 <- ggplot(pdata, aes(t, value, colour=factor(coefficient))) + geom_line()
  p1 <- p1 + facet_wrap(~ coefficient, ncol=trunc(sqrt(k)), scales="free_y")
  p1 <- p1 + theme_bw()
  p1
  
  # histograms
  p2 <- ggplot(pdata, aes(x=value, y=..density.., fill=factor(coefficient),
                          colour=factor(coefficient))) + 
    geom_histogram(bins=40)
  p2 <- p2 + geom_vline(data=aggregate(pdata[4], pdata[2], mean), 
                        mapping=aes(xintercept = true.mu), colour="red")
  p2 <- p2 + facet_wrap(~ coefficient, ncol=trunc(sqrt(k)), scales="free")
  
  p2 <- p2 + theme_bw()
  p2    
  
  
  list(p1, p2)
}

# leapfrog integrator from Hamiltonian dynamics
# theta:  parameter of interest
# r:  momentum variable
# epsilon:  step size parameter
# logDENS:  log of joint density of parameter of interest
#   (log likelihood)
# ... additional parameters to pass to logDENS
leapfrog <- function(theta, r, epsilon, logDENS, glogDENS, X, lastSTEP=FALSE, ...) {
  # require(pracma)
  # g.ld <- grad(logDENS, theta, y=y, X=X, ...)
  # print(theta)
  g.ld <- glogDENS(theta, X=X, ...)
  r.new <- r + epsilon/2*g.ld
  theta.new <- theta + epsilon*as.numeric(r.new)
  # print(theta.new)
  # g.ld.new <- grad(logDENS, theta.new, y=y, X=X, ...)
  g.ld.new <- glogDENS(theta.new, X=X, ...)
  if (!lastSTEP) {
    r.new <- r.new + epsilon/2*g.ld.new
  }
  
  list(theta.new=theta.new, 
       r.new=as.numeric(r.new))
}

# theta.init:  initial values of theta
# Nstep:  number of steps (called L in paper)
# M:  number of times to repeat
# epsilon:  step size
# logDENS:  log of joint density of parameter of interest
# ...:  additional parameters to pass to logDENS
hmc <- function(M, theta.init, epsilon, Nstep, logDENS, glogDENS, X, verbose=FALSE, ...) {
  require(MASS)
  p <- length(theta.init) # number of parameters
  mu.p <- rep(0, p)
  
  # store theta and momentum (usually not of interest)
  theta <- list()
  theta[[1]] <- theta.init
  r <- list()
  r[[1]] <- NA
  accept <- 0
  for (m in 2:M) {
    theta[[m]] <- theta.new <- theta[[m-1]]
    r0 <- mvrnorm(1, mu.p, diag(p))
    r.new <- r[[m]] <- r0
    for (i in 1:Nstep) {
      lstp <- i == Nstep
      lf <- leapfrog(theta.new, r.new, epsilon, logDENS, glogDENS, X, lastSTEP=lstp)
      theta.new <- lf$theta.new
      r.new <- lf$r.new
    }
    
    if (verbose) print(m)
    
    # standard metropolis-hastings update
    u <- runif(1)
    
    
    # use log transform for ratio due to low numbers
    num <- logDENS(theta.new, X=X) - 0.5*(r.new %*% r.new)
    den <- logDENS(theta[[m-1]], X=X) - 0.5*(r0 %*% r0)

    log.alpha <- pmin(0, num - den)
    
    # log.alpha <- pmin(0, logDENS(theta.new, y=y, X=X, ...) - 0.5*(r.new %*% r.new) - 
    #                      logDENS(theta[[m-1]], y=y, X=X, ...) - 0.5*(r0 %*% r0))
    # 
    if (log(u) < log.alpha) {
      theta[[m]] <- theta.new
      r[[m]] <- -r.new
      accept <- accept + 1
    } else {
      theta[[m]] <- theta[[m-1]]
      r[[m]] <- r[[m-1]]
    }
    # print(theta[[m]])
    # print(m)
    
  }
  list(theta=theta, 
       r=r, 
       accept=accept)
}

# log likelihood of gamma
llgamma <- function(theta, x) {
  alpha <- theta[1]
  beta <- theta[2]
  n <- length(x)
  -n*alpha*log(beta) - n*log(gamma(alpha)) + (alpha-1)*sum(log(x)) - sum(x)/beta
}


# log posterior of gamma
# theta = (alpha, beta)
# theta1 = hyperparameter for halfnormal alpha
# theta2 = hyperparameter for halfnormal beta
# https://www.rdocumentation.org/packages/fdrtool/versions/1.2.15/topics/halfnormal
gamma.posterior <- function(theta, X, theta1=1e-4, theta2=1e-4) {
  alpha <- theta[1]
  beta <- theta[2]
  llgamma(theta, X) + log(2*theta1/pi) - beta^2 * theta1^2/pi + log(2*theta2/pi) - alpha^2 * theta2^2/pi
}

# derivative of posterior
g.gamma.posterior <- function(theta, X, theta1=1e-4, theta2=1e-4) {
  alpha <- theta[1]
  beta <- theta[2]
  n <- length(X)
  dalpha <- -n*log(beta) -n*digamma(alpha) + sum(log(X)) - 2*alpha*theta2^2/pi
  dbeta <- -n*alpha/beta + sum(X)/beta/beta - 2*beta*theta1^2/pi
  c(dalpha, dbeta)
}

```




```{r, echo=FALSE}

# ----------------------------------------------------------------------------------------------
# Metropolis-Hastings algorithm
# ----------------------------------------------------------------------------------------------
# N:  number of iterations
# param.init:  initial value in chain
# qPROP:  function to generate proposal
# qFUN:  probability for proposal function. 
#    first argument is where to evaluate, and second argument is the conditional parameter
# pdFUN:  log posterior density function.  Can be unnormalized
# ... additional parameters for pdFUN

MH <- function(N, paramInit, qPROP, qFUN, pdFUN, ...) {
  paramSim <- list()
  paramSim[[1]] <- paramInit
  accept <- 0
  for (j in 2:N) {
    u <- runif(1)
    paramProposal <- qPROP(paramSim[[j-1]])
    lnum <- pdFUN(paramProposal, ...) + log(qFUN(paramSim[[j-1]], paramProposal))
    lden <- pdFUN(paramSim[[j-1]], ...) + log(qFUN(paramProposal, paramSim[[j-1]]))
    l.alpha <- pmin(0, lnum - lden)
    if (l.alpha > log(u)) {
      paramSim[[j]] <- paramProposal
      accept <- accept + 1
    } else {
      paramSim[[j]] <- paramSim[[j-1]]
    }
  }
  list(paramSim = paramSim, 
       accept = accept)
}


# q(theta1 | theta2, nu) where nu is a kxk positive definite matrix
qfun <- function(theta1, theta2) {
  k <- length(theta1)
  nu <- diag(1e-3, k, k)
  require(mvtnorm)
  mvtnorm::dmvnorm(theta1, theta2, nu)
}

# sample from proposal density
qprop <- function(theta1) {
  k <- length(theta1)
  require(MASS)
  nu <- diag(1e-2, k, k)
  mvrnorm(1, theta1, nu)
}

# proposal function in form expected by mh
pfun <- function(PARAM, ...) {
  d <- length(PARAM)
  theta <- PARAM
  gamma.posterior(theta=theta, ...)
}



```

## Run MH for Gamma distribution

```{r, echo=TRUE}

# simulate data
set.seed(312)
X <- rgamma(1000, 2, 1/3)

```

```{r, echo=TRUE, message=FALSE}

Nmh <- 5000
theta.init <- c(3, 4)

set.seed(222)
mh.res <- MH(N = Nmh, paramInit = theta.init, qPROP = qprop, qFUN = qfun, 
             pdFUN=pfun, X=X)
```

Acceptance rate

```{r, echo=FALSE, message=FALSE}

mh.param <- mh.res$paramSim
mh.param <- as.data.frame(do.call(rbind, mh.param))

colnames(mh.param) <- c("alpha", "beta")
# stripchart(mh.param$alpha, method="stack")
param.mh <- mh.param$alpha
param.mh2 <- mh.param$beta
mh.res$accept/Nmh

```

## Run HMC for Gamma distribution


```{r, echo=TRUE}
N <- Nmh
set.seed(143)
hmc.results <- hmc(M = N, theta.init = c(3, 4), epsilon = 2e-2, Nstep = 22, 
                   logDENS = gamma.posterior, glogDENS = g.gamma.posterior, X=X)
```

Acceptance rate

```{r, echo=FALSE}

hmc.results.param <- as.data.frame(do.call(rbind, hmc.results$theta))

hmc.results.momentum <- as.data.frame(do.call(rbind, hmc.results$r))
hmc.results.momentum$V1[1] <- hmc.results.momentum$V2[1] <- 0

colnames(hmc.results.param) <- c("alpha", "beta")

param <- hmc.results.param$alpha
momentum <- hmc.results.momentum$V1

param2 <- hmc.results.param$beta
momentum2 <- hmc.results.momentum$V2
hmc.results$accept/N

```

Animation $\alpha$

```{r anim, fig.width=7, fig.height=9, fig.show='animate', interval=0.2, aniopts='controls,speed', echo=FALSE}
par(mfrow=c(2, 2))
rg <- c(2:100, seq(150, N, by=50))
for (k in rg) {
  y2 <- c(-5, 5); x2 <- c(1.5, 2.7)
  y1 <- c(-23, 23); x1 <- c(0.9, 3.1)
  if (k <= 40) {
    xlm <- x1; ylm <- y1
  } else {
    xlm <- x2; ylm <- y2
  }
  
  plot(param, momentum, type='n', xlim=xlm, ylim=ylm, main="EHMC Accepted", 
       xlab=expression(alpha^(t)), ylab=expression(p^(t)))
  points(param[1:k], momentum[1:k], pch=16)
  # abline(v=2, col='blue')
  lines(param[1:k], momentum[1:k], lty=2)
  if (!param[k-1] == param[k])
    arrows(param[k-1], momentum[k-1], param[k], momentum[k], col='red')
  legend('topleft', c(expression(alpha), expression(paste(p^(t), ",", alpha^(t)))), 
         col=c('blue', 'red'), lwd=2)

  stripchart(param.mh[1:k], method="stack", at=0, main = "Metropolis-Hastings Accepted", 
             xlab=expression(alpha^(t)))
  
  plot(1:k, param[1:k], type='l', ylim=xlm, main="EHMC Trace Plot", xlab='t', ylab=expression(alpha^(t)))
  # stripchart(param[1:k], method="stack")
  # abline(h=2, col='blue')
  
  plot(1:k, param.mh[1:k], type='l', ylim=xlm, main="Metropolis-Hastings Trace Plot", xlab='t', 
       ylab=expression(alpha^(t)))
  # abline(h=2, col='blue')
}

```

```{r, echo=TRUE}
# EHMC
quantile(param, probs = c(0.05, 0.25, 0.50, 0.75, 0.95))

# Metropolis-Hastings
quantile(param.mh, probs = c(0.05, 0.25, 0.50, 0.75, 0.95))

```

Animation $\beta$

```{r anim2, fig.width=7, fig.height=9, fig.show='animate', interval=0.2, aniopts='controls,speed', echo=FALSE}
par(mfrow=c(2, 2))
rg <- c(2:100, seq(150, N, by=50))
for (k in rg) {
  y2 <- c(-5, 5); x2 <- c(2, 4)
  y1 <- c(-23, 23); x1 <- c(0.9, 5)
  if (k <= 40) {
    xlm <- x1; ylm <- y1
  } else {
    xlm <- x2; ylm <- y2
  }
  
  plot(param2, momentum2, type='n', xlim=xlm, ylim=ylm, main="EHMC Accepted", 
       xlab=expression(beta^(t)), ylab=expression(p^(t)))
  points(param2[1:k], momentum2[1:k], pch=16)
  # abline(v=3, col='blue')
  lines(param2[1:k], momentum2[1:k], lty=2)
  if (!param2[k-1] == param2[k])
    arrows(param2[k-1], momentum2[k-1], param2[k], momentum2[k], col='red')
  legend('topleft', c(expression(beta), expression(paste(p^(t), ",", beta^(t)))), 
         col=c('blue', 'red'), lwd=2)

  stripchart(param.mh2[1:k], method="stack", at=0, main = "Metropolis-Hastings Accepted", 
             xlab=expression(beta^(t)))
  
  plot(1:k, param2[1:k], type='l', ylim=xlm, main="EHMC Trace Plot", xlab='t', ylab=expression(beta^(t)))
  # stripchart(param[1:k], method="stack")
  # abline(h=3, col='blue')
  
  plot(1:k, param.mh2[1:k], type='l', ylim=xlm, main="Metropolis-Hastings Trace Plot", xlab='t', 
       ylab=expression(beta^(t)))
  # abline(h=3, col='blue')
}

```

```{r, echo=TRUE}
# EHMC
quantile(param2, probs = c(0.05, 0.25, 0.50, 0.75, 0.95))

# Metropolis-Hastings
quantile(param.mh2, probs = c(0.05, 0.25, 0.50, 0.75, 0.95))

```


```{r, echo=FALSE}
calc_posterior <- function(alpha, beta, X) {
  theta <- c(alpha, beta)
  gamma.posterior(theta=theta, X=X)
}

angval <- 20
lval <- 0.15

# contour plot of gamma posterior
alpha.vals <- seq(1, 5, by=.1)
beta.vals <- seq(1, 5, by=.1)
allcomb <- expand.grid(alpha.vals, beta.vals)
posterior.vals <- mapply(calc_posterior, alpha=allcomb[, 1], beta=allcomb[, 2], MoreArgs=list(X=X))
z <- matrix(posterior.vals, nrow=length(alpha.vals))

# add a line
par(mfrow=c(1, 2), oma=c(0,0,3,0))
contour(alpha.vals, beta.vals, z, col=terrain.colors(12)[2], lty="solid",  nlevels=20,
        vfont=c("sans serif", "plain"), xlab=expression(alpha), ylab=expression(beta), 
        main="EHMC")
arrows(param[1], param2[1], param[2], param2[2], angle=angval, length=lval)
arrows(param[2], param2[2], param[3], param2[3], angle=angval, length=lval)
#arrows(param[3], param2[3], param[4], param2[4])
#text(2, 3, labels="X", col='red')
text(param[1]+.3, param2[1]+.3, labels=expression(paste(alpha^(0), beta^(0))), col='blue')
text(param[2]+.2, param2[2]+.2, labels=expression(paste(alpha^(1), beta^(1))), col='blue')
text(param[3]+.4, param2[3]-.2, labels=expression(paste(alpha^(2), beta^(2))), col='blue')
#text(param[4]+.3, param2[4]+.2, labels=expression(paste(alpha^(3), beta^(3))), col='blue')

contour(alpha.vals, beta.vals, z, col=terrain.colors(12)[2], lty="solid",  nlevels=20,
        vfont=c("sans serif", "plain"), xlab=expression(alpha), ylab=expression(beta), 
        main="MH")
arrows(param.mh[1], param.mh2[1], param.mh[3], param.mh2[3], angle=angval, length=lval)
#arrows(param.mh[3], param.mh2[3], param.mh[4], param.mh2[4])
#text(2, 3, labels="X", col='red')
text(param.mh[1]+.2, param.mh2[1]+.4, labels=expression(paste(paste(alpha^(0), beta^(0)),
                                                              paste(alpha^(1), beta^(1)))), col='blue')
text(param.mh[3]-.2, param.mh2[3]-.2, labels=expression(paste(alpha^(2), beta^(2))), col='blue')
#text(param.mh[4]+.3, param.mh2[4]+.2, labels=expression(paste(alpha^(3), beta^(3))), col='blue')
mtext("MCMC Transitions on Contour of Log Posterior", outer=TRUE, cex=1.5)
par(mfrow=c(1, 1))
```
